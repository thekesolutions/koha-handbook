# Koha Objects System: DBIx::Class Integration Architecture

## Overview

Koha implements a sophisticated object-relational mapping (ORM) system that bridges DBIx::Class (DBIC) with a higher-level object abstraction layer. This system provides both raw database access and business logic encapsulation.

## Architecture Layers

### 1. Database Schema Layer (DBIx::Class)
- **Location**: `Koha/Schema/Result/*.pm`
- **Purpose**: Direct database table mapping
- **Generated**: Auto-generated by DBIx::Class::Schema::Loader
- **Example**: `Koha::Schema::Result::Borrower`

```perl
# Raw DBIC Result class
package Koha::Schema::Result::Borrower;
use base 'DBIx::Class::Core';
__PACKAGE__->table("borrowers");
__PACKAGE__->add_columns(
    "borrowernumber" => { data_type => "integer", is_auto_increment => 1 },
    "cardnumber"     => { data_type => "varchar", size => 32 },
    # ... more columns
);
```

### 2. Koha Object Wrapper Layer
- **Location**: `Koha/*.pm` (singular objects), `Koha/*s.pm` (collections)
- **Purpose**: Business logic and API abstraction
- **Base Classes**: `Koha::Object` and `Koha::Objects`
- **Example**: `Koha::Patron` wraps `Koha::Schema::Result::Borrower`

```perl
# Koha Object wrapper
package Koha::Patron;
use base qw(Koha::Object);

sub _type {
    return 'Borrower';  # Links to Schema::Result::Borrower
}

# Business logic methods
sub is_adult { ... }
sub get_checkouts { ... }
```

## Key Integration Mechanisms

### 1. The `_result` Bridge
Every `Koha::Object` contains a `_result` attribute that holds the underlying DBIx::Class row object:

```perl
# In Koha::Object
sub _result {
    my ($self) = @_;
    $self->{_result} ||= 
        Koha::Database->new()->schema()->resultset( $self->_type() )->new( {} );
    return $self->{_result};
}
```

### 2. Method Delegation via AUTOLOAD
`Koha::Object` automatically delegates unknown method calls to the underlying DBIC result:

```perl
# In Koha::Object::AUTOLOAD
sub AUTOLOAD {
    my $self = shift;
    my $method = our $AUTOLOAD;
    $method =~ s/.*:://;
    
    # Delegate to DBIC result
    my $r = eval { $self->_result->$method(@_) };
    # ... error handling
}
```

### 3. Column Access Pattern
Database columns are accessible through both layers:

```perl
# Direct DBIC access
my $name = $patron->_result->get_column('firstname');
$patron->_result->set_column('firstname', 'John');

# Koha::Object wrapper (preferred)
my $name = $patron->firstname;
$patron->firstname('John');
```

## Practical Usage Patterns

### Creating Objects

```perl
# Method 1: Via Koha::Objects search
my $patron = Koha::Patrons->find($borrowernumber);

# Method 2: Direct instantiation
my $patron = Koha::Patron->new({ 
    firstname => 'John',
    surname   => 'Doe' 
});

# Method 3: From DBIC result
my $dbic_row = $schema->resultset('Borrower')->find($id);
my $patron = Koha::Patron->_new_from_dbic($dbic_row);
```

### Database Operations

```perl
# Create
my $patron = Koha::Patron->new(\%data)->store;

# Read
my $patron = Koha::Patrons->find($id);
my @patrons = Koha::Patrons->search({ categorycode => 'ST' });

# Update
$patron->firstname('Jane')->store;

# Delete
$patron->delete;
```

### Relationship Navigation

```perl
# Via Koha::Object methods (preferred)
my $checkouts = $patron->checkouts;
my $category = $patron->category;

# Via DBIC relationships (lower level)
my $checkouts_rs = $patron->_result->issues;
```

## Benefits of the Dual Layer System

### 1. **Separation of Concerns**
- **DBIC Layer**: Pure data access, relationships, constraints
- **Koha Layer**: Business logic, validation, API formatting

### 2. **Backward Compatibility**
- Existing DBIC code continues to work
- Gradual migration to Koha::Object patterns

### 3. **Enhanced Functionality**
- Type safety and validation
- Consistent API patterns
- Plugin hooks and events
- REST API integration

### 4. **Testing Benefits**
- Mock objects can be created at either layer
- Business logic testing separate from database concerns

## Best Practices

### 1. **Prefer Koha::Object Methods**
```perl
# Good
my $name = $patron->firstname;
my $checkouts = $patron->checkouts;

# Avoid (unless necessary)
my $name = $patron->_result->get_column('firstname');
```

### 2. **Use Appropriate Layer for Task**
```perl
# Business logic: Koha::Object layer
if ($patron->is_adult) { ... }

# Complex queries: DBIC layer
my $rs = $schema->resultset('Borrower')->search(
    { 'issues.date_due' => { '<' => \'NOW()' } },
    { join => 'issues' }
);
```

### 3. **Transaction Handling**
```perl
# Use schema transactions for consistency
$schema->txn_do(sub {
    $patron->store;
    $patron->add_message({ message => 'Welcome!' });
});
```

## Common Patterns in Plugin Development

### 1. **Extending Existing Objects**
```perl
# In plugin
package Koha::Plugin::MyPlugin;

sub after_biblio_action {
    my ($self, $params) = @_;
    my $biblio = $params->{biblio};  # Koha::Biblio object
    
    # Access DBIC for complex operations
    my $items_rs = $biblio->_result->items;
    
    # Use Koha::Object for business logic
    my $items = $biblio->items;
}
```

### 2. **Creating Custom Result Classes**
```perl
# Custom result class
package MyPlugin::Schema::Result::CustomTable;
use base 'DBIx::Class::Core';
__PACKAGE__->table('my_custom_table');

# Corresponding Koha::Object
package MyPlugin::CustomObject;
use base 'Koha::Object';
sub _type { return 'CustomTable'; }
```

## Performance Considerations

### 1. **Lazy Loading**
- DBIC relationships are lazy-loaded by default
- Koha::Object preserves this behavior
- Use `prefetch` for eager loading when needed

### 2. **ResultSet Reuse**
```perl
# Efficient: reuse resultset
my $patrons_rs = Koha::Patrons->search({ categorycode => 'ST' });
while (my $patron = $patrons_rs->next) { ... }

# Less efficient: multiple object creation
my @patrons = Koha::Patrons->search({ categorycode => 'ST' });
```

### 3. **Direct DBIC for Bulk Operations**
```perl
# For bulk updates, use DBIC directly
$schema->resultset('Borrower')->search({ 
    categorycode => 'OLD' 
})->update({ categorycode => 'NEW' });
```

## Schema Management and Regeneration

### Schema File Generation
The DBIx::Class schema files in `Koha/Schema/Result/*.pm` are auto-generated and should not be manually edited. Koha provides tools to regenerate these files when database schema changes occur.

### Core Schema Regeneration Script
```bash
# Regenerate all schema files
perl misc/devel/update_dbic_class_files.pl

# The script will:
# 1. Connect to your Koha database
# 2. Introspect the current schema
# 3. Regenerate all Koha::Schema::Result::* files
# 4. Preserve any custom relationships or methods in the "DO NOT MODIFY" sections
```

### KTD Development Workflow
For developers using Koha Testing Docker (KTD), use the `dbic` script for schema regeneration:

```bash
# In your KTD environment
ktd --shell

# Inside the container, regenerate schema files
dbic

# This script:
# 1. Creates a temporary 'dbic' database with fresh structure
# 2. Loads kohastructure.sql (base schema without sample data)
# 3. Runs update_dbix_class_files.pl against the clean schema
# 4. Generates schema files based on pure database structure
```

**Important**: The `dbic` script does NOT affect your main koha_kohadev database - it uses a separate temporary database purely for schema file generation.

### When to Regenerate Schema Files

#### Required Regeneration:
- **Database structure changes**: New tables, columns, or indexes
- **Relationship modifications**: Foreign key changes
- **Data type updates**: Column type or constraint changes
- **After database updates**: Following installer/data/mysql/updatedatabase.pl runs

#### Best Practices:
```bash
# Before schema regeneration
git status  # Ensure clean working directory
git stash   # Stash any uncommitted changes

# After regeneration
git diff    # Review generated changes
git add Koha/Schema/Result/
git commit -m "Update DBIC schema files for [description]"
```

### Custom Schema Extensions
When adding custom tables (e.g., in plugins), you may need to extend the schema generation:

```perl
# In plugin installer
CREATE TABLE plugin_custom_table (
    id int(11) NOT NULL AUTO_INCREMENT,
    name varchar(255) NOT NULL,
    PRIMARY KEY (id)
);

# After table creation, regenerate schema
system('perl misc/devel/update_dbic_class_files.pl');
```

### Troubleshooting Schema Issues

#### Common Problems:
1. **Missing relationships**: Check foreign key constraints in database
2. **Incorrect column types**: Verify database column definitions
3. **Namespace conflicts**: Ensure table names don't conflict with existing classes

#### Debugging Commands:
```bash
# Check database structure
DESCRIBE tablename;
SHOW CREATE TABLE tablename;

# Verify foreign keys
SELECT * FROM information_schema.KEY_COLUMN_USAGE 
WHERE TABLE_SCHEMA = 'koha_kohadev' AND TABLE_NAME = 'tablename';

# Test schema loading
perl -MKoha::Database -e "print 'Schema loaded successfully\n'"
```

## Debugging and Introspection

### 1. **Examining the DBIC Layer**
```perl
# See the underlying SQL
$ENV{DBIC_TRACE} = 1;
my $patrons = Koha::Patrons->search({ surname => 'Smith' });

# Inspect result source
my $source = $patron->_result->result_source;
my @columns = $source->columns;
my %relationships = $source->relationships;
```

### 2. **Object State Inspection**
```perl
# Get all column data
my $data = $patron->unblessed;

# Check if object is in storage
my $in_storage = $patron->in_storage;

# Get primary key
my @pk = $patron->id;
```

This dual-layer architecture provides Koha with both the power of DBIx::Class and the convenience of a business-logic-aware object system, making it easier to maintain data consistency while providing rich functionality for both core development and plugin creation.

## The Koha::Object(s)::Limit::Library Pattern

### Overview

The `Koha::Object::Limit::Library` and `Koha::Objects::Limit::Library` pattern provides a standardized way to implement library-specific restrictions on Koha objects. This pattern allows certain objects (like item types, authorized values, patron categories) to be limited to specific libraries, enabling multi-tenant functionality within a single Koha installation.

### Architecture Components

#### 1. Mixin Classes
- **`Koha::Object::Limit::Library`**: Provides library limitation functionality for individual objects
- **`Koha::Objects::Limit::Library`**: Provides library-aware search functionality for object collections

#### 2. Database Structure
Library limitations are stored in dedicated junction tables following the pattern:
- **Table naming**: `{object_type}_branches` (e.g., `itemtypes_branches`, `authorised_values_branches`)
- **Columns**: Object identifier + `branchcode`
- **Relationships**: Foreign keys to both the main object table and the `branches` table

### Implementation Pattern

#### Step 1: Object Class Setup
```perl
package Koha::ItemType;
use base qw(Koha::Object Koha::Object::Limit::Library);

# Configure the library limits mapping
sub _library_limits {
    return {
        class   => "ItemtypesBranch",    # DBIC Result class name
        id      => "itemtype",           # Object identifier column
        library => "branchcode",         # Library identifier column
    };
}
```

#### Step 2: Collection Class Setup
```perl
package Koha::ItemTypes;
use base qw(Koha::Objects Koha::Objects::Limit::Library);

# The collection automatically inherits library-aware search methods
```

#### Step 3: Database Schema
```sql
-- Junction table for library limits
CREATE TABLE itemtypes_branches (
    itemtype VARCHAR(10) NOT NULL,
    branchcode VARCHAR(10) NOT NULL,
    PRIMARY KEY (itemtype, branchcode),
    FOREIGN KEY (itemtype) REFERENCES itemtypes(itemtype) ON DELETE CASCADE,
    FOREIGN KEY (branchcode) REFERENCES branches(branchcode) ON DELETE CASCADE
);
```

#### Step 4: DBIC Result Class
```perl
package Koha::Schema::Result::ItemtypesBranch;
use base 'DBIx::Class::Core';

__PACKAGE__->table("itemtypes_branches");
__PACKAGE__->add_columns(
    "itemtype",   { data_type => "varchar", is_foreign_key => 1, size => 10 },
    "branchcode", { data_type => "varchar", is_foreign_key => 1, size => 10 },
);

# Relationships to parent objects
__PACKAGE__->belongs_to("itemtype", "Koha::Schema::Result::Itemtype", 
    { itemtype => "itemtype" });
__PACKAGE__->belongs_to("branchcode", "Koha::Schema::Result::Branch", 
    { branchcode => "branchcode" });
```

### API Methods

#### Individual Object Methods (Koha::Object::Limit::Library)

##### Managing Library Limits
```perl
# Add a library limit
$itemtype->add_library_limit('CPL');

# Remove a library limit  
$itemtype->del_library_limit('CPL');

# Replace all library limits
$itemtype->replace_library_limits(['CPL', 'MPL']);

# Get/set library limits (dual-purpose accessor)
my $limits = $itemtype->library_limits();           # Returns Koha::Libraries
$itemtype->library_limits(['CPL', 'MPL']);          # Sets limits

# Get current library limits
my $libraries = $itemtype->get_library_limits();    # Returns Koha::Libraries or undef
```

#### Collection Methods (Koha::Objects::Limit::Library)

##### Library-Aware Searching
```perl
# Search respecting library limits for current user's library
my $itemtypes = Koha::ItemTypes->search_with_library_limits(
    { description => { -like => '%book%' } },  # Search parameters
    { order_by => 'description' },             # Search attributes  
    'CPL'                                      # Library code (optional)
);

# If no library specified, uses current user's library from context
my $itemtypes = Koha::ItemTypes->search_with_library_limits(
    { description => { -like => '%book%' } }
);
```

### Practical Usage Examples

#### Example 1: ItemType with Library Limits
```perl
# Create an item type limited to specific libraries
my $itemtype = Koha::ItemType->new({
    itemtype => 'LOCALBOOK',
    description => 'Local Collection Books'
})->store();

# Limit to two libraries
$itemtype->library_limits(['MAIN', 'BRANCH1']);

# Check current limits
my $limited_libraries = $itemtype->library_limits();
if ($limited_libraries) {
    say "Limited to: " . join(', ', map { $_->branchname } $limited_libraries->as_list);
} else {
    say "Available to all libraries";
}

# Search for item types available to a specific library
my $available_itemtypes = Koha::ItemTypes->search_with_library_limits(
    {},                    # No additional filters
    { order_by => 'description' },
    'BRANCH1'             # Library code
);
```

#### Example 2: AuthorisedValue with Library Limits
```perl
# Create an authorized value with library restrictions
my $av = Koha::AuthorisedValue->new({
    category => 'LOC',
    authorised_value => 'SPECIAL',
    lib => 'Special Collection'
})->store();

# Limit to main library only
$av->add_library_limit('MAIN');

# Search for authorized values available to current user's library
my $available_values = Koha::AuthorisedValues->search_with_library_limits(
    { category => 'LOC' }
);
```

### Search Logic Details

The `search_with_library_limits` method implements an inclusive OR logic:
- Returns objects with **no library limits** (available to all libraries)
- **OR** objects with limits that **include** the specified library

```sql
-- Generated SQL logic
SELECT * FROM itemtypes 
LEFT JOIN itemtypes_branches ON itemtypes.itemtype = itemtypes_branches.itemtype
WHERE (
    itemtypes_branches.branchcode IS NULL     -- No limits = available to all
    OR itemtypes_branches.branchcode = 'CPL'  -- Or specifically limited to CPL
)
```

### Integration with Koha Features

#### Template Integration
```perl
# In a template toolkit template
[% FOREACH itemtype IN itemtypes %]
    <option value="[% itemtype.itemtype | html %]">
        [% itemtype.description | html %]
    </option>
[% END %]

# The controller would use:
my $itemtypes = Koha::ItemTypes->search_with_library_limits(
    {},
    { order_by => 'description' },
    C4::Context->userenv->{branch}
);
```

#### REST API Integration
```perl
# In a REST API endpoint
sub list {
    my $c = shift->openapi->valid_input or return;
    
    my $itemtypes = Koha::ItemTypes->search_with_library_limits(
        {},
        { order_by => 'description' },
        $c->stash('koha.user')->branchcode
    );
    
    return $c->render(status => 200, openapi => $itemtypes);
}
```

### Error Handling

The pattern includes built-in exception handling:

```perl
use Try::Tiny;

try {
    $itemtype->add_library_limit('INVALID_BRANCH');
} catch {
    if (blessed $_ && $_->isa('Koha::Exceptions::CannotAddLibraryLimit')) {
        warn "Failed to add library limit: " . $_->message;
    }
};
```

### Performance Considerations

#### Efficient Queries
- Library limit checks use LEFT JOINs to maintain performance
- Indexes on junction tables improve query speed
- The pattern avoids N+1 query problems through proper JOIN usage

#### Caching Strategies
```perl
# Library limits are typically cached at the application level
my $cache_key = "itemtype_limits_" . $itemtype->itemtype;
my $limits = $cache->get_from_cache($cache_key);
unless ($limits) {
    $limits = $itemtype->library_limits();
    $cache->set_in_cache($cache_key, $limits, { expiry => 300 });
}
```

### Testing the Pattern

#### Unit Test Example
```perl
# Test library limits functionality
my $itemtype = $builder->build_object({ class => 'Koha::ItemTypes' });
my $library1 = $builder->build_object({ class => 'Koha::Libraries' });
my $library2 = $builder->build_object({ class => 'Koha::Libraries' });

# Add library limit
$itemtype->add_library_limit($library1->branchcode);

# Test search with limits
my $results = Koha::ItemTypes->search_with_library_limits(
    { itemtype => $itemtype->itemtype },
    {},
    $library1->branchcode
);
is($results->count, 1, 'Item type found for authorized library');

$results = Koha::ItemTypes->search_with_library_limits(
    { itemtype => $itemtype->itemtype },
    {},
    $library2->branchcode  
);
is($results->count, 0, 'Item type not found for unauthorized library');
```

### Best Practices

#### 1. Consistent Naming
- Junction tables: `{object_type}_branches`
- DBIC classes: `{ObjectType}sBranch`
- Always use `branchcode` for the library column

#### 2. Transaction Safety
```perl
# Always use transactions when modifying limits
$schema->txn_do(sub {
    $object->replace_library_limits(\@new_limits);
});
```

#### 3. User Context Awareness
```perl
# Always consider the current user's library context
my $user_library = C4::Context->userenv->{branch};
my $results = $objects->search_with_library_limits({}, {}, $user_library);
```

#### 4. Documentation
```perl
=head3 _library_limits

Configure library limits for this object type.

Returns a hashref with:
- class: The DBIC Result class for the junction table
- id: The column name for this object's identifier  
- library: The column name for the library identifier (usually 'branchcode')

=cut

sub _library_limits {
    return {
        class   => "ItemtypesBranch",
        id      => "itemtype", 
        library => "branchcode",
    };
}
```

This pattern provides a robust, standardized approach to implementing library-specific restrictions across different object types in Koha, ensuring consistent behavior and maintainable code.
