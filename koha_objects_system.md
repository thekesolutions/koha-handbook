# Koha Objects System: DBIx::Class Integration Architecture

## Overview

Koha implements a sophisticated object-relational mapping (ORM) system that bridges DBIx::Class (DBIC) with a higher-level object abstraction layer. This system provides both raw database access and business logic encapsulation.

## Architecture Layers

### 1. Database Schema Layer (DBIx::Class)
- **Location**: `Koha/Schema/Result/*.pm`
- **Purpose**: Direct database table mapping
- **Generated**: Auto-generated by DBIx::Class::Schema::Loader
- **Example**: `Koha::Schema::Result::Borrower`

```perl
# Raw DBIC Result class
package Koha::Schema::Result::Borrower;
use base 'DBIx::Class::Core';
__PACKAGE__->table("borrowers");
__PACKAGE__->add_columns(
    "borrowernumber" => { data_type => "integer", is_auto_increment => 1 },
    "cardnumber"     => { data_type => "varchar", size => 32 },
    # ... more columns
);
```

### 2. Koha Object Wrapper Layer
- **Location**: `Koha/*.pm` (singular objects), `Koha/*s.pm` (collections)
- **Purpose**: Business logic and API abstraction
- **Base Classes**: `Koha::Object` and `Koha::Objects`
- **Example**: `Koha::Patron` wraps `Koha::Schema::Result::Borrower`

```perl
# Koha Object wrapper
package Koha::Patron;
use base qw(Koha::Object);

sub _type {
    return 'Borrower';  # Links to Schema::Result::Borrower
}

# Business logic methods
sub is_adult { ... }
sub get_checkouts { ... }
```

## Key Integration Mechanisms

### 1. The `_result` Bridge
Every `Koha::Object` contains a `_result` attribute that holds the underlying DBIx::Class row object:

```perl
# In Koha::Object
sub _result {
    my ($self) = @_;
    $self->{_result} ||= 
        Koha::Database->new()->schema()->resultset( $self->_type() )->new( {} );
    return $self->{_result};
}
```

### 2. Method Delegation via AUTOLOAD
`Koha::Object` automatically delegates unknown method calls to the underlying DBIC result:

```perl
# In Koha::Object::AUTOLOAD
sub AUTOLOAD {
    my $self = shift;
    my $method = our $AUTOLOAD;
    $method =~ s/.*:://;
    
    # Delegate to DBIC result
    my $r = eval { $self->_result->$method(@_) };
    # ... error handling
}
```

### 3. Column Access Pattern
Database columns are accessible through both layers:

```perl
# Direct DBIC access
my $name = $patron->_result->get_column('firstname');
$patron->_result->set_column('firstname', 'John');

# Koha::Object wrapper (preferred)
my $name = $patron->firstname;
$patron->firstname('John');
```

## Practical Usage Patterns

### Creating Objects

```perl
# Method 1: Via Koha::Objects search
my $patron = Koha::Patrons->find($borrowernumber);

# Method 2: Direct instantiation
my $patron = Koha::Patron->new({ 
    firstname => 'John',
    surname   => 'Doe' 
});

# Method 3: From DBIC result
my $dbic_row = $schema->resultset('Borrower')->find($id);
my $patron = Koha::Patron->_new_from_dbic($dbic_row);
```

### Database Operations

```perl
# Create
my $patron = Koha::Patron->new(\%data)->store;

# Read
my $patron = Koha::Patrons->find($id);
my @patrons = Koha::Patrons->search({ categorycode => 'ST' });

# Update
$patron->firstname('Jane')->store;

# Delete
$patron->delete;
```

### Relationship Navigation

```perl
# Via Koha::Object methods (preferred)
my $checkouts = $patron->checkouts;
my $category = $patron->category;

# Via DBIC relationships (lower level)
my $checkouts_rs = $patron->_result->issues;
```

## Benefits of the Dual Layer System

### 1. **Separation of Concerns**
- **DBIC Layer**: Pure data access, relationships, constraints
- **Koha Layer**: Business logic, validation, API formatting

### 2. **Backward Compatibility**
- Existing DBIC code continues to work
- Gradual migration to Koha::Object patterns

### 3. **Enhanced Functionality**
- Type safety and validation
- Consistent API patterns
- Plugin hooks and events
- REST API integration

### 4. **Testing Benefits**
- Mock objects can be created at either layer
- Business logic testing separate from database concerns

## Best Practices

### 1. **Prefer Koha::Object Methods**
```perl
# Good
my $name = $patron->firstname;
my $checkouts = $patron->checkouts;

# Avoid (unless necessary)
my $name = $patron->_result->get_column('firstname');
```

### 2. **Use Appropriate Layer for Task**
```perl
# Business logic: Koha::Object layer
if ($patron->is_adult) { ... }

# Complex queries: DBIC layer
my $rs = $schema->resultset('Borrower')->search(
    { 'issues.date_due' => { '<' => \'NOW()' } },
    { join => 'issues' }
);
```

### 3. **Transaction Handling**
```perl
# Use schema transactions for consistency
$schema->txn_do(sub {
    $patron->store;
    $patron->add_message({ message => 'Welcome!' });
});
```

## Common Patterns in Plugin Development

### 1. **Extending Existing Objects**
```perl
# In plugin
package Koha::Plugin::MyPlugin;

sub after_biblio_action {
    my ($self, $params) = @_;
    my $biblio = $params->{biblio};  # Koha::Biblio object
    
    # Access DBIC for complex operations
    my $items_rs = $biblio->_result->items;
    
    # Use Koha::Object for business logic
    my $items = $biblio->items;
}
```

### 2. **Creating Custom Result Classes**
```perl
# Custom result class
package MyPlugin::Schema::Result::CustomTable;
use base 'DBIx::Class::Core';
__PACKAGE__->table('my_custom_table');

# Corresponding Koha::Object
package MyPlugin::CustomObject;
use base 'Koha::Object';
sub _type { return 'CustomTable'; }
```

## Performance Considerations

### 1. **Lazy Loading**
- DBIC relationships are lazy-loaded by default
- Koha::Object preserves this behavior
- Use `prefetch` for eager loading when needed

### 2. **ResultSet Reuse**
```perl
# Efficient: reuse resultset
my $patrons_rs = Koha::Patrons->search({ categorycode => 'ST' });
while (my $patron = $patrons_rs->next) { ... }

# Less efficient: multiple object creation
my @patrons = Koha::Patrons->search({ categorycode => 'ST' });
```

### 3. **Direct DBIC for Bulk Operations**
```perl
# For bulk updates, use DBIC directly
$schema->resultset('Borrower')->search({ 
    categorycode => 'OLD' 
})->update({ categorycode => 'NEW' });
```

## Schema Management and Regeneration

### Schema File Generation
The DBIx::Class schema files in `Koha/Schema/Result/*.pm` are auto-generated and should not be manually edited. Koha provides tools to regenerate these files when database schema changes occur.

### Core Schema Regeneration Script
```bash
# Regenerate all schema files
perl misc/devel/update_dbic_class_files.pl

# The script will:
# 1. Connect to your Koha database
# 2. Introspect the current schema
# 3. Regenerate all Koha::Schema::Result::* files
# 4. Preserve any custom relationships or methods in the "DO NOT MODIFY" sections
```

### KTD Development Workflow
For developers using Koha Testing Docker (KTD), use the `dbic` script for schema regeneration:

```bash
# In your KTD environment
ktd --shell

# Inside the container, regenerate schema files
dbic

# This script:
# 1. Creates a temporary 'dbic' database with fresh structure
# 2. Loads kohastructure.sql (base schema without sample data)
# 3. Runs update_dbix_class_files.pl against the clean schema
# 4. Generates schema files based on pure database structure
```

**Important**: The `dbic` script does NOT affect your main koha_kohadev database - it uses a separate temporary database purely for schema file generation.

### When to Regenerate Schema Files

#### Required Regeneration:
- **Database structure changes**: New tables, columns, or indexes
- **Relationship modifications**: Foreign key changes
- **Data type updates**: Column type or constraint changes
- **After database updates**: Following installer/data/mysql/updatedatabase.pl runs

#### Best Practices:
```bash
# Before schema regeneration
git status  # Ensure clean working directory
git stash   # Stash any uncommitted changes

# After regeneration
git diff    # Review generated changes
git add Koha/Schema/Result/
git commit -m "Update DBIC schema files for [description]"
```

### Custom Schema Extensions
When adding custom tables (e.g., in plugins), you may need to extend the schema generation:

```perl
# In plugin installer
CREATE TABLE plugin_custom_table (
    id int(11) NOT NULL AUTO_INCREMENT,
    name varchar(255) NOT NULL,
    PRIMARY KEY (id)
);

# After table creation, regenerate schema
system('perl misc/devel/update_dbic_class_files.pl');
```

### Troubleshooting Schema Issues

#### Common Problems:
1. **Missing relationships**: Check foreign key constraints in database
2. **Incorrect column types**: Verify database column definitions
3. **Namespace conflicts**: Ensure table names don't conflict with existing classes

#### Debugging Commands:
```bash
# Check database structure
DESCRIBE tablename;
SHOW CREATE TABLE tablename;

# Verify foreign keys
SELECT * FROM information_schema.KEY_COLUMN_USAGE 
WHERE TABLE_SCHEMA = 'koha_kohadev' AND TABLE_NAME = 'tablename';

# Test schema loading
perl -MKoha::Database -e "print 'Schema loaded successfully\n'"
```

## Debugging and Introspection

### 1. **Examining the DBIC Layer**
```perl
# See the underlying SQL
$ENV{DBIC_TRACE} = 1;
my $patrons = Koha::Patrons->search({ surname => 'Smith' });

# Inspect result source
my $source = $patron->_result->result_source;
my @columns = $source->columns;
my %relationships = $source->relationships;
```

### 2. **Object State Inspection**
```perl
# Get all column data
my $data = $patron->unblessed;

# Check if object is in storage
my $in_storage = $patron->in_storage;

# Get primary key
my @pk = $patron->id;
```

This dual-layer architecture provides Koha with both the power of DBIx::Class and the convenience of a business-logic-aware object system, making it easier to maintain data consistency while providing rich functionality for both core development and plugin creation.
